[ ] Vector similarity search fails to surface thematically-related memories because it only captures semantic proximity, not abstract relationships like "TV On The Radio" â†’ "2010s indie music appreciation". The system needs to understand conceptual hierarchies and thematic connections beyond just word-level similarity to retrieve memories at different abstraction levels.

[ ] **Procedural memory reimagining as extension to `invokeother_tool`**: Reconceive procedural memory as documentation-based guidance integrated with the invokeother_tool pattern rather than a separate manager system. Add `lookup_procedure` capability to retrieve step-by-step documentation for multi-step processes. Store procedures as structured documentation (markdown/JSON) that `invokeother_tool` can query. Enable LLM to request procedure details when uncertain about execution steps. Examples: "how to reset user password", "deployment checklist", "debug process for X". Integrates with existing tool discovery pattern - procedures are discoverable like tools. See `junk_drawer/future_enhancement_snippets/procedural_memory/REINTEGRATION_GUIDE.md` for the original implementation and reintegration plan.

[ ] **Codeanalysis tool with headless Claude Code integration**: Build a `codeanalysis_tool` that invokes Claude Code in headless mode (`claude -p`) to enable MIRA to analyze its own codebase. This creates meta-programming capabilities where MIRA can investigate architecture, identify patterns, perform code reviews, and answer questions about implementation details without manual human intervention. Tool would wrap headless Claude calls with JSON output parsing, session management for multi-turn analysis, and strict tool allowlisting (only Read, Glob, Grep to prevent dangerous operations). Key considerations: rate limiting to prevent API abuse, session isolation per user, clear error handling for malformed analysis requests. Use cases: debugging complex issues by analyzing related code, understanding architectural patterns before implementing features, automated code quality checks, cross-component impact analysis. Requires security boundaries to ensure headless invocations can't execute arbitrary operations or access other users' data.